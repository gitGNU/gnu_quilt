#! @BASH@

#  This script is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License version 2 as
#  published by the Free Software Foundation.
#
#  See the COPYING and AUTHORS files for more details.
# Read in library functions
if [ "$(type -t patch_file_name)" != function ]
then
	if ! [ -r @SCRIPTS@/patchfns ]
	then
		echo "Cannot read library @SCRIPTS@/patchfns" >&2
		exit 1
	fi
	. @SCRIPTS@/patchfns
fi

usage()
{
	local redirect
	if [ x$1 != x-h ]
	then
		redirect='>&2'
	fi
	echo $"Usage: quilt refresh [-p n] [-f] [k|o] [patch]" $redirect
	
	if [ x$1 = x-h ]
	then
		echo $"

Refreshes the specified patch, or the topmost patch by default.
Documentation that comes before the actual patch in the patch file is
retained.

It is possible to refresh patches that are not on top.  If any patches
on top of the patch to refresh modify the same files, the script aborts
by default.  Patches can still be refreshed with -f.  In that case this
script will print a warning for each shadowed file, changes by more
recent patches will be ignored, and only changes in files that have not
been modified by any more recent patches will end up in the specified
patch.

-p n	Create a -p n style patch (-p0 or -p1 supported).
	
-f	Force refresh, even if more recent patches modify
	some of the same files.
-O 	Overwrite the quilt save patches (for gendiff)
-K	Keep the quilt save patches unchanged (for gendiff)

	
"
		exit 0
	else
		exit 1
	fi
}

die ()
{
	local status=$1
	[ -n "$tmpfile" ] && rm -f $tmpfile
	[ -n "$tmpfile2" ] && rm -f $tmpfile2
	exit $status
}
#
# readln reads a line into $ans.
#
#	readln prompt default oldval
#
function readln () {
	echo -n $1
	read ans 
	if [ -z "$ans" ]; then
		opt_Overwrite=1
		return 0
	fi
	if [ $ans == 'O' -o $ans == 'o' ]; then
		opt_Overwrite=1
		return 0
	elif [ $ans == 'K' -o $ans == 'k' ]; then
		opt_Keep=1
		return 0
	fi
	return 1
}
backup_files ()
{
	local file_list=`cat $1`
	local base_dir=$2
	
	for file in $file_list; do
		backup_file=$(basename $file)
		backup_dir=${base_dir}$(dirname $file)
		mkdir -p $backup_dir
		cp .pc/$$file $backup_dir/$backup_file
	done
}
save_patches ()
{
	local patch=$1
	local saved_patch=$(save_patch_name $patch)
	local patch_file=$(patch_file_name $patch)
	local saved_pc_file=$(pc_file_name $saved_patch)	

	if  [ -e $saved_pc_file ]; then
		if [ $opt_Keep -eq 0 -a $opt_Overwrite -eq 0 ]; then
			while :; do
				readln "$patch save exist Overwrite/Keep:" "O"
				if [ $? -eq 0 ]; then	
					break
				fi	
			done
		fi
	else
		opt_Overwrite=1
	fi
	if [ $opt_Overwrite -eq 1 ]; then
		rm -rf .pc/$saved_patch
		cp -a .pc/$patch .pc/$saved_patch
		current_dir=$(pwd)
		cd .pc/$saved_patch
		@PATCH@	-p1 -s -i "${current_dir}/${patch_file}" 
		cd $current_dir 
	fi
}
options=`getopt -o kop:fh -- "$@"`

if [ $? -ne 0 ]
then
	usage
fi
opt_Overwrite=0
opt_Keep=0
eval set -- "$options"

while true
do
	case "$1" in
	-p)
		opt_strip_level=$2
		shift 2 ;;
	-f)
		opt_force=1
		shift ;;
	-k)
		opt_Keep=1
		shift ;;
	-o)
		opt_Overwrite=1
		shift ;;
	-h)
		usage -h ;;
	--)
		shift
		break ;;
	esac
done

if [ $# -eq 1 ]
then
	opt_patch=$1
elif [ $# -gt 1 ]
then
	usage
fi

if [ -n "$opt_patch" ]
then
	patch=$(stripit $opt_patch)
else
	patch=$(top_patch)
	if [ -z "$patch" ]
	then
		echo $"No patch seem to be applied" >&2
		exit 1
	fi
fi

if ! is_applied "$patch"
then
	echo $"Patch $patch is not applied" >&2
	exit 1
fi

if [ -z "$opt_strip_level" ]
then
	opt_strip_level=$(patch_strip_level $patch)
fi
if [ $opt_strip_level -gt 1 ]
then
	echo $"Cannot refresh patches with -p$opt_strip_level, please specify -p0 or -p1 instead" >&2
	exit 1
fi

save_patches $patch

trap "die 1" SIGTERM

tmpfile=$(gen_tempfile)

for file in $(files_in_patch $patch)
do
	old_file=$(backup_file_name $patch $file)
	next_patch=$(next_patch_for_file $patch $file)
	if [ -z "$next_patch" ]
	then
		new_file=$file
	else
		new_file=$(backup_file_name $next_patch $file)
		files_were_shadowed=1
	fi
	if ! diff_file $file $old_file $new_file >> $tmpfile
	then
		echo $"Diff failed, aborting." >&2
		die 1
	fi

	if [ -n "$files_were_shadowed" -a -z "$opt_force" ]
	then
		echo $"More recent patches modify files in $patch. Enforce refresh with -f." >&2
		die 1
	fi
done

if ! [ -s $tmpfile ]
then
	echo $"Nothing in patch $patch" >&2
	die 1
fi

patch_file=$(patch_file_name $patch)

trap "" SIGINT

if [ -e $patch_file ] && grep -q '^%patch$' $patch_file
then
	if [ -x "@DIFFSTAT@" ]
	then
		@DIFFSTAT@ $tmpfile 2>/dev/null \
		| @SCRIPTS@/parse-patch -u diffstat $patch_file
	fi
	cat $tmpfile \
	| @SCRIPTS@/parse-patch -u patch $patch_file
else
	if ! tmpfile2=$(gen_tempfile)
	then
		die 1
	fi

	mkdir -p $(dirname $patch_file)

	if ! cat_file $patch_file \
	     | patch_description > $tmpfile2 || \
	   ! cat $tmpfile >> $tmpfile2 || \
	   ! cat $tmpfile2 \
	     | cat_to_file $patch_file
	then
		die 1
	fi
fi
if [ $? -ne 0 ]
then
	die 1
fi

rm -f $(pc_file_name $patch)~refresh
echo $"Refreshed patch $patch"
if ! change_db_strip_level -p$opt_strip_level $patch
then
	die 1
fi
die 0
### Local Variables:
### mode: shell-script
### End:
# vim:filetype=sh
