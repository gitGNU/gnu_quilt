#! @BASH@

#  This script is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License version 2 as
#  published by the Free Software Foundation.
#
#  See the COPYING and AUTHORS files for more details.
# Read in library functions
if [ "$(type -t patch_file_name)" != function ]
then
	if ! [ -r @SCRIPTS@/patchfns ]
	then
		echo "Cannot read library @SCRIPTS@/patchfns" >&2
		exit 1
	fi
	. @SCRIPTS@/patchfns
fi

usage()
{
	echo $"Usage: $0 [-fRq] patchname"
	exit 1
}

files_may_have_changed()
{
	local patch=$1 file
	local patch_file=$(patch_file_name $patch)
	
	if [ $? -ne 0 -o ! -e "$patch_file" -o ! -e ".pc/$patch/.timestamp" \
	     -o ".pc/$patch/.timestamp" -ot "$patch_file" ]
	then
		return 0
	fi
	local apply_ts=$(date -r ".pc/$patch/.timestamp" '+%s') ts
	for file in $(files_in_patch $patch)
	do
		ts=$(date -r $file '+%s' 2> /dev/null)
		[ -z "$ts" ] && return 0
		[ "$ts" -gt $apply_ts ] && return 0
	done
	return 1
}

# Check if all changes have been folded back into the patch (quilt refresh),
# and report any pending changes.
check_for_pending_changes()
{
	local patch=$1 pc_file=$2
	local patch_file=$(patch_file_name $patch)
	local patch_args=$(patch_args $patch)
	local workdir=$(gen_tempfile -d quilt) status=0

	if [ -d .pc/$patch ]
	then
		if ! rmdir $workdir ||  # note that this is racey...
		   ! cp -rl .pc/$patch $workdir/
		then
			echo $"Failed to copy files to temporary directory"
			rm -rf $workdir
			return 1
		fi

		# Now we may have some zero-size files that have no
		# permissions (which represent files that the patch
		# creates). Those may have been created in the meantime,
		# but patch would refuse to touch them: We must remove
		# them here.
		find $workdir -type f -size 0 -exec rm -f '{}' ';'

	fi
	
	if [ -s $patch_file ]
	then
		if ! cat_file $patch_file \
		     | @PATCH@ -d $workdir $patch_args \
			       --no-backup-if-mismatch -E \
			       >/dev/null 2>/dev/null
		then
			# If a patch was force applied (and therefore needs
			# refreshing), we know that patching the temporary
			# files won't succeed, either. So, ignore the error
			# in that particular case.
			
			if ! [ -e .pc/$patch ]
			then
				echo $"Failed to patch temporary files"
				rm -rf $workdir
				return 1
			fi
		fi
	fi
	
	local remains=$(gen_tempfile)
	while read file
	do
		diff_file $file $workdir/$file $file >> $remains
	done < $pc_file
	
	if [ -s $remains ]
	then
		echo $"Patch $patch does not remove cleanly (enforce with -f or -R)."
		status=1
	fi
	rm -f $remains
	rm -rf $workdir

	return $status
}

reverse_patch()
{
	local patch=$1
	local patch_file=$(patch_file_name $patch)

	if ! [ -s $patch_file ]
	then
		echo $"Patch file $patch_file appears to be empty"
		return 0
	fi
	
	if [ "x${patch_file:(-3)}" = "x.gz" ]
	then
		gzip -cd $patch_file \
		| @PATCH@ $(patch_args $patch) --no-backup-if-mismatch \
			-R -E $silent
	elif [ "x${patch_file:(-4)}" = "x.bz2" ]
	then
		bzip2 -cd $patch_file \
		| @PATCH@ $(patch_args $patch) --no-backup-if-mismatch \
			-R -E $silent
	else
		@PATCH@ $(patch_args $patch) --no-backup-if-mismatch \
			-R -E $silent -i $patch_file
	fi
}

rpatch()
{
	local patch=$1 pc_file=$(gen_tempfile) status=0

	# FIXME backup-files should scan the directory tree itself.
	files_in_patch $patch > $pc_file
	if ! [ -s $pc_file ]
	then
		echo $"Patch $patch appears to be empty, removed"
		remove_from_db $patch
		return 0
	fi

	trap "" SIGINT
	if [ -z "$opt_force" ]
	then
		for file in $(touched_by_patch $(patch_strip_level $patch) $patch) 
		do
			if ! [ -e ".pc/$patch/$file" ]
			then
				echo "$file touched by $patch_file"
				echo "but no backup files for $file"
				echo "Please Make sure your $patch_file is right"
				echo "otherwise, quilt push $patch will be failed" 
				echo "Please quilt pop with -f option"
				echo "Suggestion: If you have done make distclean" 
				echo "in kernel src, it will delete 0 size file"
				echo "Maybe you should delete those new created files"
				return 0
			fi
		done
	fi
        if [ -n "$opt_remove" ]
	then
		reverse_patch $patch
	        remove_from_db $patch
	        rm -f .pc/$patch~refresh
	else
		if [ -z "$opt_force" ] && ( files_may_have_changed $patch )
		then
			check_for_pending_changes $patch $pc_file || status=1
		fi
		if [ $status -eq 0 ]
		then
			echo $"Removing $patch"
			rm -f ".pc/$patch/.timestamp"
			@LIB@/backup-files $silent -f $pc_file -B .pc/$patch/ -r
			status=$?
			remove_from_db $patch
			rm -f .pc/$patch~refresh
		fi
	fi
	rm -f $pc_file
	trap - SIGINT
	return $status
}

options=`getopt -o fRqvh -- "$@"`

if [ $? -ne 0 ]
then
	usage
fi
#opt_force=0
#opt_remove=0
eval set -- "$options"

while true
do
	case "$1" in
	-f)
		opt_force=1
		shift ;;
	-R)
		opt_remove=1  # remove properly with patch -R; no tricks
		unset opt_force
		shift ;;
	-q)
		opt_quiet=1 
		shift ;;
	-v)
		opt_verbose=1
		shift ;;
	-h)
		usage -h ;;
	--)
		shift
		break ;;
	esac
done

if [ $# -ne 1 ]
then
	usage
fi

patch=$(stripit $1)
[ -n "$opt_quiet" ] && silent=-s
[ -z "$opt_verbose" ] && silent_unless_verbose=-s

top=$(top_patch)
if [ -n "$top" -a -e .pc/$top~refresh -a -z "$opt_force" ]
then
	echo $"The topmost patch $top needs to be refreshed first."
	exit 1
fi

rpatch "$patch" || exit 1
### Local Variables:
### mode: shell-script
### End:
# vim:filetype=sh
